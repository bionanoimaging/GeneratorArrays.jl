var documenterSearchIndex = {"docs":
[{"location":"distance/#Concrete-GeneratorArrays","page":"Distance Functions","title":"Concrete GeneratorArrays","text":"","category":"section"},{"location":"distance/","page":"Distance Functions","title":"Distance Functions","text":"rr2","category":"page"},{"location":"distance/#GeneratorArrays.rr2","page":"Distance Functions","title":"GeneratorArrays.rr2","text":"rr2([T=Float64], size::size::NTuple{N, Int};\n    offset=CtrFT,\n    scale=ScaUnit)\n\nCalculates the squared radius to a reference pixel. In this case CtrFT is the center defined by the FFT convention. ScaUnit leaves the values unscaled. offset and scale can be either of < :Ctr, Sca respectively or simply tuples with the same shape as size. Look at ?Ctr and Sca for all options.\n\nNote that this function is based on a GeneratorArray and therefore does not allocate the full memory needed to represent the array.\n\nExamples\n\njulia> rr2((4, 4))\n4×4 GeneratorArray{Float64, 2, GeneratorArrays.var\"#4#5\"{Float64, Tuple{Float64, Float64}, Tuple{Int64, Int64}}}:\n 8.0  5.0  4.0  5.0\n 5.0  2.0  1.0  2.0\n 4.0  1.0  0.0  1.0\n 5.0  2.0  1.0  2.0\n\njulia> rr2((3, 3))\n3×3 GeneratorArray{Float64, 2, GeneratorArrays.var\"#4#5\"{Float64, Tuple{Float64, Float64}, Tuple{Int64, Int64}}}:\n 2.0  1.0  2.0\n 1.0  0.0  1.0\n 2.0  1.0  2.0\n\njulia> rr2((3, 3), offset=(1, 1))\n3×3 GeneratorArray{Float64, 2, GeneratorArrays.var\"#4#5\"{Float64, Tuple{Int64, Int64}, Tuple{Int64, Int64}}}:\n 0.0  1.0  4.0\n 1.0  2.0  5.0\n 4.0  5.0  8.0\n\njulia> rr2(Int, (3, 3), offset=(1, 1), scale=(10, 10))\n3×3 GeneratorArray{Int64, 2, GeneratorArrays.var\"#4#5\"{Int64, Tuple{Int64, Int64}, Tuple{Int64, Int64}}}:\n   0  100  400\n 100  200  500\n 400  500  800\n\n\n\n\n\n","category":"function"},{"location":"window/#Window-Functions","page":"Window Functions","title":"Window Functions","text":"","category":"section"},{"location":"#GeneratorArrays.jl","page":"GeneratorArrays.jl","title":"GeneratorArrays.jl","text":"","category":"section"},{"location":"","page":"GeneratorArrays.jl","title":"GeneratorArrays.jl","text":"Here you can find the docstrings of all functions. We also provide several concrete generators.","category":"page"},{"location":"#GeneratorArray-Interface","page":"GeneratorArrays.jl","title":"GeneratorArray Interface","text":"","category":"section"},{"location":"","page":"GeneratorArrays.jl","title":"GeneratorArrays.jl","text":"The abstract GeneratorArray definition","category":"page"},{"location":"","page":"GeneratorArrays.jl","title":"GeneratorArrays.jl","text":"GeneratorArray","category":"page"},{"location":"#GeneratorArrays.GeneratorArray","page":"GeneratorArrays.jl","title":"GeneratorArrays.GeneratorArray","text":"GeneratorArray([T], gen::F, size::NTuple{N,Int}) where {N,F}\n\nGenerate a GeneratorArray object which behaves like an array but does not allocate the full array. Instead it calculates the elements when needed. This is useful to prevent array allocations. gen is a function which takes the array indices wrapped as tuple as input. The output of gen determines the element type of the resulting array. size is the output size of the resulting array. T can be the optional element type of the arrays.  gen needs to have T as return type, otherwise the GeneratorArray might be type unstable.\n\nExamples\n\njulia> GeneratorArray(x -> sum(x), (3, 3))\n3×3 GeneratorArray{Int64, 2, var\"#182#183\"}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> GeneratorArray(x -> sum(abs2.(x)), (3, 3))\n3×3 GeneratorArray{Int64, 2, var\"#184#185\"}:\n  2   5  10\n  5   8  13\n 10  13  18\n\njulia> GeneratorArray(x -> (x[1], x[2], \"Julia\"), (3,3))\n3×3 GeneratorArray{Tuple{Int64, Int64, String}, 2, var\"#18#19\"}:\n (1, 1, \"Julia\")  (1, 2, \"Julia\")  (1, 3, \"Julia\")\n (2, 1, \"Julia\")  (2, 2, \"Julia\")  (2, 3, \"Julia\")\n (3, 1, \"Julia\")  (3, 2, \"Julia\")  (3, 3, \"Julia\")\n\n\n\n\n\n","category":"type"}]
}
